---
title: "CINSARC Analysis_STUMP"
output: html_document
date: "2025-06-18"
editor_options: 
  chunk_output_type: console
---
```{r download packages, eval=FALSE, include=FALSE}
# Via Bioconductor
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("txdbmaker")

# Via Cran
install.packages("annotables")

# Via Github
install.packages("devtools")
devtools::install_github("stephenturner/annotables")
```

```{r library, eval=FALSE, include=FALSE}
# Setup
setwd(dir = "/Volumes/Multiomics/Scripts/CINSARC analysis/STUMP/")
library(edgeR)       # For normalization
library(org.Hs.eg.db) # For gene annotation (Ensembl/Entrez/Symbol mapping)
library(biomaRt)     # Optional, for more flexible annotation
library(dplyr)
library(tibble)
library(tidyverse)
library(rtracklayer)  
library(annotables)
# Survival analysis
library(scales)
library(survival)
library(DESeq2)
library(survminer)
```

```{r General variables, include=FALSE}
# General variables
# Color for lines representing different strata
C1COL='#1839E7'
C2COL='#E71839'
C3COL='purple'
# CINSARC genes (H2AX/H2AFX,SGO2/SGOL2)
CINSARC=c("ANLN","ASPM","AURKA","AURKB","BIRC5","BORA","BUB1","BUB1B","CCNA2",
          "CCNB1","CCNB2","CDC20","CDC45","CDC6","CDC7","CDCA2","CDCA3","CDCA8",
          "CDK1","CENPA","CENPE","CENPL","CEP55","CHEK1","CKAP5","CKS2","ECT2",
          "ESPL1","FANCI","FBXO5","FOXM1","H2AX","HP1BP3","KIF11","KIF14","KIF15",
          "KIF18A","KIF20A","KIF23","KIF2C","KIF4A","MAD2L1","MCM2","MCM7","MELK",
          "NCAPH","NDE1","NEK2","NUF2","OIP5","PBK","PLK4","PRC1","PTTG1","RAD51AP1",
          "RNASEH2A","RRM2","SGO2","SMC2","SPAG5","SPC25","TOP2A","TPX2","TRIP13",
          "TTK","UBE2C","ZWINT") # ,"KIFC1" add if needed
```

* CINSARC analysis
    * Requires two inputs: 
        * clinical data containing metastastic status with numerically-ordered samples in the column 
        * log2-transformed FPKM-normalized RNA-seq expression matrix with CINSARC genes in the rows and numerically-ordered samples in the column
          * pipeline for RNA-seq expression matrix processing: see Lesluyes et al., 2020
    * Generates outputs: risk group assignment (C1 and C2) and centroids for each sample.

```{r}
# -------------------------------
# Step 0: Load libraries
# -------------------------------
suppressPackageStartupMessages({
  library(tidyverse)
  library(rtracklayer)
  library(edgeR)
})

# -------------------------------
# Step 1: Read raw counts
# -------------------------------
counts_raw <- read_tsv("/Volumes/Multiomics/Scripts/CINSARC analysis/STUMP/featureCounts/June17/merged_featureCounts.txt", comment = "#", col_types = cols())

# Confirm structure
head(counts_raw)

# -------------------------------
# Step 2: Extract count matrix and gene info
# -------------------------------
annot_cols <- c("Geneid", "Chr", "Start", "End", "Strand", "Length")

gene_info <- counts_raw %>% dplyr::select(all_of(annot_cols))
count_mat <- counts_raw %>% dplyr::select(-all_of(annot_cols))

# Clean Ensembl gene IDs (drop version numbers)
gene_ids <- gsub("\\..*", "", gene_info$Geneid)
rownames(count_mat) <- gene_ids
gene_lengths <- gene_info$Length
names(gene_lengths) <- gene_ids

# -------------------------------
# Step 3: Load gene symbol annotation from GTF
# -------------------------------
gtf <- import("gencode.v38.annotation.gtf")
gtf_genes <- gtf[gtf$type == "gene"]
gene_annot <- as.data.frame(mcols(gtf_genes)[, c("gene_id", "gene_name")])
gene_annot$gene_id <- gsub("\\..*", "", gene_annot$gene_id)  # Remove version

# -------------------------------
# Step 4: Merge annotation
# -------------------------------
# Convert to data frame
counts_df <- count_mat %>%
  as.data.frame() %>%
  rownames_to_column("gene_id")

# Join with HGNC symbols
annotated_counts <- left_join(counts_df, gene_annot, by = "gene_id")

# Replace missing symbols with gene_id
annotated_counts$gene_name[is.na(annotated_counts$gene_name)] <- annotated_counts$gene_id

# -------------------------------
# Step 5: Collapse duplicated gene symbols by summing
# -------------------------------
collapsed_counts <- annotated_counts %>%
  select(-gene_id) %>%
  group_by(gene_name) %>%
  summarise(across(where(is.numeric), sum), .groups = "drop")

# Set gene symbols as rownames
final_counts <- collapsed_counts %>%
  column_to_rownames("gene_name") %>%
  as.matrix()

# -------------------------------
# Step 6: Match gene lengths for FPKM
# -------------------------------
# For each gene symbol, pick the longest gene length
gene_lengths_df <- tibble(gene_id = gene_ids, length = gene_lengths) %>%
  left_join(gene_annot, by = "gene_id") %>%
  filter(!is.na(gene_name)) %>%
  group_by(gene_name) %>%
  summarise(length = max(length), .groups = "drop")

# Match order
gene_lengths_final <- gene_lengths_df$length[match(rownames(final_counts), gene_lengths_df$gene_name)]
names(gene_lengths_final) <- rownames(final_counts)

# -------------------------------
# Step 7: Normalize using edgeR → FPKM → log2(FPKM + 1)
# -------------------------------
dge <- DGEList(counts = final_counts)
dge <- calcNormFactors(dge, method = "TMM")

fpkm <- rpkm(dge, gene.length = gene_lengths_final)
log2_fpkm <- log2(fpkm + 1)

# -------------------------------
# Step 8: Save output
# -------------------------------
write.table(log2_fpkm,
            file = "log2_FPKM_normalized.txt",
            sep = "\t",
            quote = FALSE)

message("✅ Done! Log2(FPKM+1) matrix saved. Dimensions: ",
        nrow(log2_fpkm), " genes × ", ncol(log2_fpkm), " samples.")

```




```{r Nearest centroid method to assign prognosis, include=FALSE, echo=FALSE}
# Function to compute centroids
cit.dfAggregate <- function(data, partition, MARGIN = 1, fAggreg = mean.na) {
  cMARGIN <- setdiff(c(1, 2), MARGIN)
  n <- length(partition)
  N <- dim(data)[MARGIN]
  p <- dim(data)[cMARGIN]
  
  # Debugging prints
  cat("Dimension of data:", dim(data), "\n")
  cat("MARGIN:", MARGIN, "\n")
  cat("Length of partition:", n, "\n")
  cat("Dimension of data along MARGIN:", N, "\n")
  
  if (n != N)
    stop("Error - function cit.dfAggregate : size of partition doesn't correspond to data dimension")
  
  l <- split(1:N, partition)
  d <- data
  
  if (MARGIN == 2)
    d <- t(data)
  
  d <- matrix(sapply(l, function(i) if (length(i) == 1) {
    unlist(d[i, ])
  } else {
    apply(d[i, ], 2, fAggreg)
  }), ncol = p, byrow = TRUE)
  
  d <- as.data.frame(d)
  rownames(d) <- names(l)
  names(d) <- dimnames(data)[[cMARGIN]]
  
  if (MARGIN == 2)
    d <- as.data.frame(t(d))
  
  d
}
computeCentroids <- function(DF_clin, DF_EXP, COL_EVENT) {
  stopifnot(COL_EVENT %in% colnames(DF_clin))
  stopifnot(all(DF_clin$META %in% c(0, 1)))
  stopifnot(all(rownames(DF_clin) %in% colnames(DF_EXP)))
  cl <- rep(NA, ncol(DF_EXP))
  names(cl) <- colnames(DF_EXP)
  for (sample in colnames(DF_EXP)) {
    if (sample %in% rownames(DF_clin)) {
      cl[sample] <- DF_clin[sample, COL_EVENT]
    } else {
      warning(paste("Sample", sample, "not found in DF_clin"))
    }
  }
  
  # Print for debugging
  cat("cl vector:\n")
  print(cl)
  
  # Scale and transpose expression data
  dd <- t(scale(t(DF_EXP), scale = FALSE))
  
  # Print for debugging
  cat("Scaled and transposed expression data (dd):\n")
  print(head(dd))
  
  # Compute centroids
  L <- list()
  L$centroids <- cit.dfAggregate(dd, cl, MARGIN = 2, fAggreg = mean)
  
  return(L)
}

# Function to apply centroids
applyCentroids=function(DF,L) {
  stopifnot(identical(rownames(DF),rownames(L$centroids)))
  tdist=data.frame(1-cor(t(scale(t(DF),scale=F))[rownames(L$centroids),],L$centroids,method="spearman"),stringsAsFactors=F)
  tdist$pred=paste0("C",apply(tdist,1,which.min))
  return(tdist)
}

# Apply leave-one-out cross validation and assign prognostic value (make sure clinical data row names and expression matrix column names are in the right order)
CINSARC_result=lapply(1:nrow(clinical_data_tidy),function(x) applyCentroids(RNASeq_CINSARC,computeCentroids(clinical_data_tidy[-x,],RNASeq_CINSARC[,-x],"metastasis"))[x,])

CINSARC_result=do.call(rbind,CINSARC_result)
clinical_data_tidy$CINSARC=CINSARC_result$pred
view(CINSARC_result)
```

Survival analysis:
Three elements required for construction of Kaplan-Meier Curve
1. Time to event of interest
  * MFS defined as distant recurrence date if META=TRUE, OS dates if META=FALSE
  * OS
  * DFS
2. Status (including information of experiment drop-outs)
  * MFS: Metastasis
  * OS: Alive/Deceased
  * DFS: Disease-free or not
3. Stratification (CINSARC classification)

```{r Survival Analysis - CINSARC only, eval=FALSE, include=FALSE}
# Define function that conducts survival analysis and generates survival curves
myKM=function(a,col_Event,col_Time,col_Pred,MAIN,C1COL,C2COL,
                modifiedYlab="Metastasis-free survival probability",modifiedC1lab="low-risk profile",
                modifiedC2lab="high-risk profile",
                xlab="Time (years)",lwd=2) {
    stopifnot(col_Event %in% colnames(a))
    stopifnot(col_Time%in% colnames(a))
    stopifnot(col_Pred %in% colnames(a))
    stopifnot(identical(c("C1","C2"),sort(unique(as.character(a[,col_Pred])))))
    if (is.character(a[,col_Pred])) a[,col_Pred]=factor(a[,col_Pred],levels=c("C1","C2"))
    index=which(apply(a[,c(col_Event,col_Time,col_Pred)],1,function(x) length(which(is.na(x) | x=="")))>0)
    if (length(index)>0) a=a[-index,]
    rm(index)
    C1=length(which(a[,col_Pred]=="C1"))
    C2=length(which(a[,col_Pred]=="C2"))
    eC1=length(which(a[,col_Pred]=="C1" & a[,col_Event]==1))
    eC2=length(which(a[,col_Pred]=="C2" & a[,col_Event]==1))
    if (!is.numeric(a[[col_Time]]) || !is.numeric(a[[col_Event]])) {
      a[[col_Time]] <- as.numeric(a[[col_Time]])
      a[[col_Event]] <- as.numeric(a[[col_Event]])
      }
    SD=survdiff(Surv(a[,col_Time], a[,col_Event])~a[,col_Pred]) # p log-rank
    stopifnot(length(SD$n)-1==1) # 1 degree of freedom
    Pval=pchisq(SD$chisq,1,lower.tail=F)
    COXPH=summary(coxph(Surv(a[,col_Time], a[,col_Event])~a[,col_Pred])) # Cox PH
    HR=round(COXPH$conf.int[1],2)
    HR_CI_DN=round(COXPH$conf.int[3],2)
    HR_CI_UP=round(COXPH$conf.int[4],2)
    View(COXPH$conf.int)
    #rm(COXPH)
    sur.all=survfit(Surv(a[,col_Time],a[,col_Event])~strata(a[,col_Pred]),data=a) # Kaplan-Meier
    plot(sur.all,col=c(C1COL,C2COL),ylab=modifiedYlab,xlab=xlab,las=0,xaxs='i',xlim=c(-0.05,max(a[,col_Time])),
         main=MAIN,lwd=lwd,cex.main=2,mark.time=T,cex.lab=1.25)
    text(x=max(a[,col_Time])/2,y=0.94,labels=paste0("HR = ",HR," [",HR_CI_DN,"-",HR_CI_UP,"]"),cex=1.125)
    text(x=max(a[,col_Time])/2,y=0.85, labels=bquote(italic(P)['log-rank'] ~ "=" ~ .(scientific_format(3)(Pval))), cex=1.125)
    legend('bottomleft',legend=c(as.expression(bquote(.(modifiedC1lab)~"("*italic(n)*.("=")*.(C1)*"):"~.(eC1)~events)),
                              as.expression(bquote(.(modifiedC2lab)~"("*italic(n)*.("=")*.(C2)*"):"~.(eC2)~events))),
           lwd=lwd,pch="-",bg="white",cex=1.125,border=NA,col=c(C1COL,C2COL),bty='n')
  }  
# Generate OS, MFS survival curves
OS_CINSARC <- myKM(clinical_data_tidy,"overal survival",
                       "overall survival_time_(years)","CINSARC",'SS_CINSARC_OS',C1COL,C2COL,
                       modifiedYlab="Overall Survival probability", modifiedC1lab="CINSARC C1",modifiedC2lab="CINSARC C2") 
MFS_CINSARC <- myKM(clinical_data_tidy,"metastasis","metastasis time_(years)","CINSARC",'SS_CINSARC_MFS ',C1COL,C2COL,
                  modifiedYlab="Metastasis-free survival probability", 
                  modifiedC1lab="CINSARC C1",modifiedC2lab="CINSARC C2")
```
